# include "Energy.h"

RotatedRect center_R = RotatedRect(Point2f(0, 0), Point2f(0, 0), Point2f(0, 0));
int SCREEN_MAX_X = 1280;//888 1280
int SCREEN_MAX_Y = 720;//1000 720
const double PI = 3.1415926535;

/******************************Energy*****************************/
// ??????????????????????????????
void Energy::getMask(Mat& frame, Mat& mask)
{
    std::vector<Mat> BGR;
    Mat BR, gray, gray_mask;
    split(frame, BGR);
    cvtColor(frame, gray, COLOR_BGR2GRAY);//???????
    threshold(gray, gray_mask, THRESH_GRAY, 255, THRESH_BINARY);

    if (IS_RED)
        BR = BGR[2] - BGR[0];
    else
        BR = BGR[0] - BGR[2];
    threshold(BR, mask, THRESH_BR, 255, THRESH_BINARY); // ?????????????????
    mask &= gray_mask;//?????????

    morphologyEx(mask, mask, MORPH_DILATE, getStructuringElement(MORPH_RECT, Size(DILATE_EOFF, DILATE_EOFF)));// ??????????3????5
    //morphologyEx(mask, mask, MORPH_DILATE, getStructuringElement(MORPH_RECT, Size(3, 3)));// ??????????3????5
    morphologyEx(mask, mask, MORPH_CLOSE, getStructuringElement(MORPH_RECT, Size(3, 3)));
}

// ?????????????????????????????????????????????????
void Energy::getSpeed(ArmorRect& present, ArmorRect& former, Mat& frame)
{
    if (!is_find) return;
    double cos_theta = present.to_center.dot(former.to_center) / (present.to_center.getNorm() * former.to_center.getNorm());
    if (acos(cos_theta) == acos(cos_theta) && abs(acos(cos_theta) * 180 / PI) < 10)
    {
        double thetas[4];
        double mean = 0;
        int count_num = 0;

        for (int i = 0; i < 4; i++)
        {
            RMvector vec1 = present.vertex2center[i];
            RMvector vec2 = former.vertex2center[i];
            thetas[i] = acos(vec1.dot(vec2) / (vec1.getNorm() * vec2.getNorm()));
        }

        for (auto& t : thetas)
        {
            if (t / PI * 180 < 10 && t / PI * 180 > 0.5)
            {
                mean += t * 180 / PI;
                count_num += 1;
                //std::cout << t * 180 / PI << " ";
            }
        }
        //std::cout << mean / count_num;
        //std::cout << std::endl;
        //std::cout << acos(cos_theta) * 180 / PI << std::endl;

        RMvector vec1(present.fan_center, center_R.center);
        RMvector vec2(former.fan_center, center_R.center);
        double fan_theta = acos(vec1.dot(vec2) / (vec1.getNorm() * vec2.getNorm()));
        double measureSpeed = (fan_theta + acos(cos_theta) * 180 / PI + mean) / (count_num + 2);

        present.setSpeed(measureSpeed);
        putText(frame, "Angle/frame" + std::to_string(measureSpeed), Point(100, 30), CV_FONT_NORMAL, 1, Scalar(0, 255, 0), 2);
        //std::cout << "before: " << (acos(cos_theta) * 180 / PI + mean) / (count_num + 1) << std::endl;
        //putText(frame, "Angle" + std::to_string((present.to_center.angle) / PI * 180), Point(100, 30), CV_FONT_NORMAL, 1, Scalar(0, 255, 0), 2);
    }
}

// ??????????????????????????????????????????©„????????????????????????
void Energy::predict(ArmorRect& present, Mat& frame)
{
    if (!is_find) return;
    //float frameNum = 20;// 3????
    // ???????????????????????
    RMvector vec = present.to_center;
    double theta = getTime * meanSpeed * PI / 180;
    //double theta = getTime * present.speed * PI / 180;
    double newx, newy;
    if (SHUN == 1)
    {
        theta = -theta;
        newx = center_R.center.x - (vec.x * cos(theta) + vec.y * sin(theta));
        newy = center_R.center.y - (-vec.x * sin(theta) + vec.y * cos(theta));
        circle(frame, Point(newx, newy), 2, Scalar(0, 255, 0), 2);
        pre_x = newx; pre_y = newy;
    }
    else if(SHUN == 2)
    {
        newx = center_R.center.x - (vec.x * cos(theta) + vec.y * sin(theta));
        newy = center_R.center.y - (-vec.x * sin(theta) + vec.y * cos(theta));
        circle(frame, Point(newx, newy), 2, Scalar(0, 255, 0), 2);
        pre_x = newx; pre_y = newy;
    }
}

// ??????¨À???äï???§Ö??????????
// ???????????????????????§Ò???????????????????????????????????
void Energy::judgeDirect(ArmorRect& present, ArmorRect& former, Mat& frame)
{
    if (!is_find) return;
    float res = former.to_center.cross(present.to_center);
    float Cos = former.to_center.dot(present.to_center) / (former.to_center.getNorm() * present.to_center.getNorm());
    if (res && fabs(Cos) > 0.9)
    {
        if (res > 0)
        {
            putText(frame, "shun", Point(100, 60), CV_FONT_NORMAL, 1, Scalar(0, 255, 0), 2);
            SHUN = 1;
        }
        else
        {
            putText(frame, "ni", Point(100, 60), CV_FONT_NORMAL, 1, Scalar(0, 255, 0), 2);
            SHUN = 2;
        }
    }
    else SHUN = 0; // ??????????????????????????????????????????????¨¹????????????
    // ??????????????????????????????????0
}

void Energy::getCoutour(Mat& mask, Mat& frame, ArmorRect& armor_center)
{
    std::vector<std::vector<Point> > armorContours;
    std::vector<Vec4i> armorHierarchy;
    findContours(mask, armorContours, armorHierarchy, RETR_TREE, CHAIN_APPROX_NONE);
    int find_flag = 0; // ?????§Ø???????
    // Hierarchy[i][0-4]: next,previous,first_child, parent

    // ??????
    int contour_size = armorContours.size();
    int* count = new int[contour_size];
    for (int k = 0; k < contour_size; k++)
        count[k] = 0;// ????

    for (int i = 0; i < contour_size; i++)
    {
        if (armorHierarchy[i][3] != -1)// ?§Ú?????
        {
            if (contourArea(armorContours[i]) > MIN_AREA) {// ????? ???count????????????????
                count[armorHierarchy[i][3]]++;
            }
        }
    }
    for (int i = 0; i < contour_size; i++)
    {
        //??????????????????????????????????count????????????????????????
        if (count[i] == 1 && contourArea(armorContours[i]) > MIN_AREA)
        {
            // ???????????????????????????????????????????????????
            int now = armorHierarchy[i][2];// now?????????????
            double max_area = (double)contourArea(armorContours[now]);
            int max_armor = now;
            while (armorHierarchy[now][0] != -1)
            {
                now = armorHierarchy[now][0];
                if ((double)contourArea(armorContours[now]) > max_area)
                {
                    max_area = (double)contourArea(armorContours[now]);
                    max_armor = now;
                }
            }
            now = armorHierarchy[i][2];
            while (armorHierarchy[now][1] != -1)
            {
                now = armorHierarchy[now][1];
                if ((double)contourArea(armorContours[now]) > max_area)
                {
                    max_area = (double)contourArea(armorContours[now]);
                    max_armor = now;
                }
            }

            // ????????????? // ?????????????????????????????????????????
            RotatedRect rotate_rect = minAreaRect(armorContours[max_armor]);
            //double long_edge = max(rotate_rect.size.width, rotate_rect.size.height);
            //double short_edge = min(rotate_rect.size.width, rotate_rect.size.height);
            //double wh_rio = long_edge / short_edge;
            //if (wh_rio > 1.2 && wh_rio < 2.5)
            if(isValidCenterArmorContour(armorContours[max_armor]))
            {
                Point2f vertices[4];
                rotate_rect.points(vertices);
                for (int j = 0; j < 4; j++)// ???????????Debug
                    //line(mask, vertices[j], vertices[(j + 1) % 4], 127, 2);
                    line(frame, vertices[j], vertices[(j + 1) % 4], Scalar(0, 255, 0), 3);
                // ??????????????????????????????????
                // ??????????????????break????????????????????????????????
                armor_center.fan_center = getCoutourCenter(armorContours[i]);
                find_flag = 1;
                armor_center.setParam(rotate_rect);
                circle(frame, armor_center.center, 1, Scalar(0, 0, 255), 2);
                circle(frame, armor_center.fan_center, 1, Scalar(0, 255, 255), 2);

                // ???????ROI
                //roi = Roi(armorContours[i]);
            }
        }

    }
    is_find = find_flag;
    delete[] count;
}

Point2f Energy::getCoutourCenter(const std::vector<Point>& coutour)
{
    int n = coutour.size();
    double x_sum = 0, y_sum = 0;
    if (n <= 0)
        return Point2f(0, 0);
    for (auto& c : coutour)
    {
        x_sum += c.x; y_sum += c.y;
    }
    return Point2f(x_sum / n, y_sum / n);
}
// ?????????????
bool Energy::isValidCenterRContour(const std::vector<Point>& center_R_contour) {
    //?????????§³??????
    double cur_contour_area = contourArea(center_R_contour);
    if (cur_contour_area > 1000 || cur_contour_area < 200)
        return false;

    //???¦Á????????
    RotatedRect cur_rect = minAreaRect(center_R_contour);
    Size2f cur_size = cur_rect.size;
    float length = cur_size.height > cur_size.width ? cur_size.height : cur_size.width;//?????¦Å???????????
    float width = cur_size.height < cur_size.width ? cur_size.height : cur_size.width;//?????¦Å??????????
    if (length < 10 || width < 10 || length >  80 || width > 80)
        return false;

    //???????????
    float length_width_ratio = length / width;//???????¦Ã?????
    if (length_width_ratio > 2 || length_width_ratio < 1)
        return false;

    // ????????¦Å???????????????
    if (cur_contour_area / cur_size.area() < 0.6)
        return false;
    return true;
}

bool Energy::isValidCenterFansContour(const std::vector<Point>& contour)
{
    //?????????§³??????
    double cur_contour_area = contourArea(contour);
    if (cur_contour_area > 25000 || cur_contour_area < 3000)
        return false;

    //???¦Á????????
    RotatedRect cur_rect = minAreaRect(contour);
    Size2f cur_size = cur_rect.size;
    float length = cur_size.height > cur_size.width ? cur_size.height : cur_size.width;//?????¦Å???????????
    float width = cur_size.height < cur_size.width ? cur_size.height : cur_size.width;//?????¦Å??????????
    if (length < 100 || width < 100 || length >  500 || width > 500)
        return false;

    //???????????
    float length_width_ratio = length / width;//???????¦Ã?????
    if (length_width_ratio > 10 || length_width_ratio < 1.5)
        return false;

    // ????????¦Å???????????????
    if (cur_contour_area / cur_size.area() < 0.2)
        return false;

    return true;
}

bool Energy::isValidCenterArmorContour(const std::vector<Point>& contour)
{
    //?????????§³??????
    double cur_contour_area = contourArea(contour);
    if (cur_contour_area > 5000 || cur_contour_area < 500)//1548
        return false;

    //???¦Á????????
    RotatedRect cur_rect = minAreaRect(contour);
    Size2f cur_size = cur_rect.size;
    float length = cur_size.height > cur_size.width ? cur_size.height : cur_size.width;//?????¦Å???????????
    float width = cur_size.height < cur_size.width ? cur_size.height : cur_size.width;//?????¦Å??????????
    if (length < 10 || width < 10 || length >  100 || width > 100)// 60, 30
        return false;

    //???????????
    float length_width_ratio = length / width;//???????¦Ã?????
    if (length_width_ratio > 3 || length_width_ratio < 1.2)
        return false;

    // ????????¦Å???????????????
    if (cur_contour_area / cur_size.area() < 0.6)
        return false;

    return true;
}

bool Energy::judgeRPosition(RotatedRect &R, ArmorRect &present, ArmorRect &former)
{
    // R.center ?? present????????????
    RMvector vec(R.center, present.center);
    RMvector armor_nvector(present.angle);
    RMvector armor_tvector(present.tangent_angle);
    RMvector fan_Rvector(present.fan_center, R.center);// ?§à???????????
    RMvector fan_armor(present.fan_center, present.center);
    // ????????????
    if (fabs(vec.dot(armor_tvector) / vec.getNorm()) > 0.15 || fabs(vec.dot(armor_nvector) / vec.getNorm()) < 0.95)
    {
        return false;
    }

    if (vec.getNorm() / present.long_edge > 10 || vec.getNorm() / present.long_edge < 2) // 3.2????
    {
        return false;
    }

    //// // ????nvec??tvec??????§Ù??????????????§Ø??????????
    //// // ???????§Ø?¦Ë????????
    //// ???????????§Ø???????????????¦Ë????????????????????????????????????????
    //// ??????§Ø??????§Ø?????????
    //if (!(SHUN==1 && vec.x > R.center.x && vec.y > R.center.y && vec.cross(armor_tvector) > 0||
    //	SHUN == 1 && vec.x < R.center.x && vec.y < R.center.y && vec.cross(armor_tvector) < 0||
    //	SHUN == 1 && vec.x > R.center.x && vec.y < R.center.y && vec.cross(armor_tvector) > 0||
    //	SHUN == 1 && vec.x < R.center.x && vec.y > R.center.y && vec.cross(armor_tvector) < 0||
    //	SHUN == 2 && vec.x > R.center.x && vec.y > R.center.y && vec.cross(armor_tvector) < 0 ||
    //	SHUN == 2 && vec.x < R.center.x && vec.y < R.center.y && vec.cross(armor_tvector) > 0 ||
    //	SHUN == 2 && vec.x > R.center.x && vec.y < R.center.y && vec.cross(armor_tvector) < 0 ||
    //	SHUN == 2 && vec.x < R.center.x && vec.y > R.center.y && vec.cross(armor_tvector) > 0))
    //{
    //	return false;
    //}

    // ???????????????????????????¦Î?????????????????????????????????
    // ???????????§Ø?R?????????????????????R,???????????
    // ?????????????§Ø??????????????????????
    // ????????¡¤??????????????????????????????????????????????????¦Ë??
    // ?????????????????????????????????¡Â?????????????????
    // ????????????????????????????????????????????????????????
    // ??????????????????????????????????????????????????????
    // ?????????????????????????§¹????????????????????????????????????????????????????????????????§Ø?????
    // ??????????????????????????????????????????????§Õ??????
    // ?????????????????????????????????????????????????????????????????????????????
    //if (center_R.center.x != 0 && center_R.center.y != 0)// ??????? // ???????????
    //{
    //	double c = former.to_center.dot(vec) / (former.to_center.getNorm() * vec.getNorm());
    //	if (c < 0.9)
    //		return false;
    //}

    // ????????
    // bug ????
    if (fan_armor.dot(fan_Rvector) >= 0)
    {
        return false;
    }

    return true;
}

void Energy::getR(Mat& mask, ArmorRect& present, ArmorRect& former)
{
    RotatedRect R;
    std::vector<std::vector<Point> > R_contours;
    findContours(mask, R_contours, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE);
    for (auto& R_contour : R_contours) {
        if (!isValidCenterRContour(R_contour)) { // ?§Ø?????
            continue;
        }
        R = minAreaRect(R_contour);
        if (judgeRPosition(R, present, former))
        {
            Point2f vertices[4];
            center_R.points(vertices);
            for (int j = 0; j < 4; j++)
                line(mask, vertices[j], vertices[(j + 1) % 4], 127, 2);
            center_R = R;
            break;
        }
    }
}
